/**
 * Bitmap Font Renderer
 * NES-style 8x8 tile-based text rendering
 * 
 * Each character is represented as an 8x8 grid of pixels
 * This is how real NES games rendered text
 */

import * as THREE from 'three'

// Simple 5x7 pixel font data (stored as binary patterns)
// Each character is 8 rows of 8 bits (though we only use 5x7)
const FONT_DATA: Record<string, number[]> = {
  'A': [0x20, 0x50, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x00],
  'B': [0xF0, 0x88, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00],
  'C': [0x70, 0x88, 0x80, 0x80, 0x80, 0x88, 0x70, 0x00],
  'D': [0xF0, 0x88, 0x88, 0x88, 0x88, 0x88, 0xF0, 0x00],
  'E': [0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0xF8, 0x00],
  'F': [0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0x80, 0x00],
  'G': [0x70, 0x88, 0x80, 0xB8, 0x88, 0x88, 0x70, 0x00],
  'H': [0x88, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88, 0x00],
  'I': [0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00],
  'J': [0x38, 0x10, 0x10, 0x10, 0x10, 0x90, 0x60, 0x00],
  'K': [0x88, 0x90, 0xA0, 0xC0, 0xA0, 0x90, 0x88, 0x00],
  'L': [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF8, 0x00],
  'M': [0x88, 0xD8, 0xA8, 0xA8, 0x88, 0x88, 0x88, 0x00],
  'N': [0x88, 0xC8, 0xA8, 0x98, 0x88, 0x88, 0x88, 0x00],
  'O': [0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00],
  'P': [0xF0, 0x88, 0x88, 0xF0, 0x80, 0x80, 0x80, 0x00],
  'Q': [0x70, 0x88, 0x88, 0x88, 0xA8, 0x90, 0x68, 0x00],
  'R': [0xF0, 0x88, 0x88, 0xF0, 0xA0, 0x90, 0x88, 0x00],
  'S': [0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00],
  'T': [0xF8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00],
  'U': [0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00],
  'V': [0x88, 0x88, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00],
  'W': [0x88, 0x88, 0x88, 0xA8, 0xA8, 0xD8, 0x88, 0x00],
  'X': [0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00],
  'Y': [0x88, 0x88, 0x50, 0x20, 0x20, 0x20, 0x20, 0x00],
  'Z': [0xF8, 0x08, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00],
  '0': [0x70, 0x88, 0x98, 0xA8, 0xC8, 0x88, 0x70, 0x00],
  '1': [0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00],
  '2': [0x70, 0x88, 0x08, 0x30, 0x40, 0x80, 0xF8, 0x00],
  '3': [0xF8, 0x08, 0x10, 0x30, 0x08, 0x88, 0x70, 0x00],
  '4': [0x10, 0x30, 0x50, 0x90, 0xF8, 0x10, 0x10, 0x00],
  '5': [0xF8, 0x80, 0xF0, 0x08, 0x08, 0x88, 0x70, 0x00],
  '6': [0x30, 0x40, 0x80, 0xF0, 0x88, 0x88, 0x70, 0x00],
  '7': [0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x40, 0x00],
  '8': [0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00],
  '9': [0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00],
  ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
  '-': [0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00],
  '!': [0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x00],
  '?': [0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00],
  '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00],
  ':': [0x00, 0x00, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00],
  '/': [0x08, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x00],
}

export interface BitmapTextOptions {
  color?: number
  scale?: number
  letterSpacing?: number
  align?: 'left' | 'center' | 'right'
}

/**
 * Create a mesh group containing text rendered as 8x8 pixel tiles
 */
export function createBitmapText(
  text: string,
  options: BitmapTextOptions = {}
): THREE.Group {
  const {
    color = 0xffffff,
    scale = 0.1,
    letterSpacing = 0,
    align = 'left',
  } = options

  const group = new THREE.Group()
  const upperText = text.toUpperCase()
  
  // Calculate total width for alignment
  const totalWidth = (upperText.length * 8 * scale) + (upperText.length - 1) * letterSpacing
  let startX = 0
  
  if (align === 'center') {
    startX = -totalWidth / 2
  } else if (align === 'right') {
    startX = -totalWidth
  }

  let xOffset = startX

  for (let i = 0; i < upperText.length; i++) {
    const char = upperText[i]
    const charData = FONT_DATA[char] || FONT_DATA[' ']
    
    const charMesh = createCharacterMesh(charData, color, scale)
    charMesh.position.x = xOffset
    group.add(charMesh)
    
    xOffset += 8 * scale + letterSpacing
  }

  return group
}

/**
 * Create a mesh for a single character from its bitmap data
 */
function createCharacterMesh(
  charData: number[],
  color: number,
  scale: number
): THREE.Group {
  const charGroup = new THREE.Group()
  const pixelSize = scale

  // Each row is a byte representing 8 pixels
  for (let row = 0; row < 8; row++) {
    const rowData = charData[row]
    
    for (let col = 0; col < 8; col++) {
      // Check if this pixel is "on" (bit is set)
      const bitMask = 1 << (7 - col)
      const isPixelOn = (rowData & bitMask) !== 0
      
      if (isPixelOn) {
        const pixelGeo = new THREE.PlaneGeometry(pixelSize, pixelSize)
        const pixelMat = new THREE.MeshBasicMaterial({ color })
        const pixel = new THREE.Mesh(pixelGeo, pixelMat)
        
        // Position pixel in character grid
        pixel.position.x = col * pixelSize
        pixel.position.y = -row * pixelSize
        
        charGroup.add(pixel)
      }
    }
  }

  return charGroup
}

/**
 * Update the text of an existing bitmap text group
 * More efficient than destroying and recreating
 */
export function updateBitmapText(
  group: THREE.Group,
  text: string,
  options: BitmapTextOptions = {}
): void {
  // Clear existing children
  while (group.children.length > 0) {
    group.remove(group.children[0])
  }

  // Add new text
  const newText = createBitmapText(text, options)
  newText.children.forEach(child => {
    group.add(child)
  })
}

/**
 * Helper to create common text styles
 */
export const BitmapTextStyles = {
  /** Large title text */
  title: (color: number = 0xffffff): BitmapTextOptions => ({
    color,
    scale: 0.15,
    letterSpacing: 0.05,
    align: 'center',
  }),

  /** Medium subtitle text */
  subtitle: (color: number = 0xffffff): BitmapTextOptions => ({
    color,
    scale: 0.1,
    letterSpacing: 0.02,
    align: 'center',
  }),

  /** Small UI text */
  small: (color: number = 0xffffff): BitmapTextOptions => ({
    color,
    scale: 0.08,
    letterSpacing: 0,
    align: 'left',
  }),
}
